; mult63.a
; from Dr Jefyll, http://forum.6502.org/viewtopic.php?f=9&t=689&start=0#p19958
; - adjusted to use fixed zero page addresses
; - removed 'decrement to avoid clc' as this is slower on average
; - unrolled the outer loop
; - unrolled the two inner loops twice
;
; 16 bit x 16 bit unsigned multiply, 32 bit result
; Average cycles: 444.00
; 185 bytes

m = $02     ;
n = $08     ; 4 bytes

* = $0200

; 16 bit x 16 bit unsigned multiply, 32 bit result
;   based on Bruce Clark's UM*
;   http://forum.6502.org/viewtopic.php?p=4389#p4389
;   Shifting strategy modified for speed - JWL (Dr Jefyll)
;
; On Entry:
;   n: *five* bytes of workspace.
;   X: zero page memory address of the two byte multiplier, four bytes needed for result
;   (n+2, n+3): two byte multiplicand
; On Exit:
;   X: preserved
;   (m+2,m+3, m, m+1): product
mult
    lda #0          ;
    sta n           ; 16 bits of zero in A, N
                    ;  Note:    First 8 shifts are  A -> N -> m+2
                    ;           Final 8 shifts are  A -> N -> m+3

    ; --- 1st byte ---
    ldy #2          ; count for inner loop
    lsr m+2

    ; inner loop (twice)
inner_loop
    ; first time
    bcc +
    sta n+1
    lda n
    clc
    adc n+2
    sta n
    lda n+1
    adc n+3
+
    ror             ; shift
    ror n
    ror m+2

    ; second time
    bcc +
    sta n+1
    lda n
    clc
    adc n+2
    sta n
    lda n+1
    adc n+3
+
    ror             ; shift
    ror n
    ror m+2

    ; third time
    bcc +
    sta n+1
    lda n
    clc
    adc n+2
    sta n
    lda n+1
    adc n+3
+
    ror             ; shift
    ror n
    ror m+2

    ; fourth time
    bcc +
    sta n+1
    lda n
    clc
    adc n+2
    sta n
    lda n+1
    adc n+3
+
    ror             ; shift
    ror n
    ror m+2
    dey
    bne inner_loop  ; go back for another shift?

    ; --- 2nd byte ---
    ldy #2          ; count for inner loop
    lsr m+3

    ; inner loop (twice)
inner_loop2
    ; first time
    bcc +
    sta n+1
    lda n
    clc
    adc n+2
    sta n
    lda n+1
    adc n+3
+
    ror             ; shift
    ror n
    ror m+3

    ; second time
    bcc +
    sta n+1
    lda n
    clc
    adc n+2
    sta n
    lda n+1
    adc n+3
+
    ror             ; shift
    ror n
    ror m+3

    ; third time
    bcc +
    sta n+1
    lda n
    clc
    adc n+2
    sta n
    lda n+1
    adc n+3
+
    ror             ; shift
    ror n
    ror m+3

    ; fourth time
    bcc +
    sta n+1
    lda n
    clc
    adc n+2
    sta n
    lda n+1
    adc n+3
+
    ror             ; shift
    ror n
    ror m+3
    dey
    bne inner_loop2 ; go back for another shift?


    sta m+1         ; ms byte of hi-word of result
    lda n
    sta m           ; ls byte of hi-word of result
    rts
